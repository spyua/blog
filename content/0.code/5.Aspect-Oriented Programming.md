 # AOP (Aspect-Oriented Programming)

## Introduction

Recently, during a discussion with a friend about mechanisms for logging, I learned about Aspect-Oriented Programming (AOP) and decided to delve a little into its usage and implementation. Although King's use of AspCore proved to be a quick way to implement AOP, I still wanted to spend some time understanding how to achieve this without relying on a framework.

AOP employs a cross-cutting technique to insert new methods into the original class without altering or disrupting the original class methods. This technique is a skillful way to introduce new functionalities into a program, enhancing its modularization and flexibility without compromising the integrity of the original code structure.

> Separate cross-cutting concerns from the core business logic to further enhance the modularity of the code!

Let me give you an example. Suppose you received the following service code that has already been written:

```csharp
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    public IXXXService(){
    
    }
    
    public void QueryData(){
        ....
    }
}
```
This service method does not provide a logging mechanism. If you want to add logging, what should you do?

The first method you might consider is directly modifying the source code.

```csharp
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    private readonly ILog _log;
    
    public IXXXService(ILog log){
        _log = log;
    }
    
    public void QueryData(){
        try{
           _log.I("QueryData");
           ....
        }
        catch(Exception e)
        {
          _log.E($"Imp QueryData " + {e.ToString()});
        }
        ....
    }
}
```

We modify the service directly by injecting your own logging function and incorporating try-catch mechanisms within the method. However, this approach clearly alters the original source code. Moreover, logging and the original logic are not directly related, so combining them isn't an ideal method.

What alternatives exist that allow us to add logging without modifying the internal code, ensuring the service retains its sole responsibility of handling business logic? One solution is to employ a simple static proxy method to achieve this.

```csharp

// 原程式碼
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    public IXXXService(){
    
    }
    
    public void QueryData(){
        ....
    }
}

//使用Proxy

public class ProxyXXX : IXXXService{

    private readonly IXXXService _xxxService;
    private readonly ILog _log;
    
    public ProxyXXX(IXXXService xxxService, ILog log){
        _xxxService = xxxService;
        _log = log;
    }
    
    public void QueryData(){
        try{
            _log.I("QueryData");
            _xxxService.QueryData();
            
        }catch(Exception e){
            _log.E($"Imp QueryData " + {e.ToString()});
        }
    }

}
```

Declare a Proxy Class to implement the IXXXService method. Since this is through a proxy, there's an opportunity to intervene before and after execution actions (try-catch, log). This allows for the addition of logging functionality without altering the original code.

This concept is essentially a form of aspect-oriented programming (AOP), which separates concerns (e.g., logging) from the business core, further decoupling them.

In more detail, many program requirements, such as logging, are not directly related to the program's logic but need to be interjected into functions at appropriate times. Such requirements are typically addressed using aspects or cross-cutting concerns. This approach separates these unrelated needs from the original logical functions, enhancing the design's modifiability and reducing coupling.

The diagram conceptually illustrates that in programming, we often need to handle functions like error logging, authentication, and potentially adding user activity tracking. By applying the AOP concept, we don't have to individually add these functionalities to each method. Instead, as indicated by the grey, yellow, and red arrows, all methods must go through authentication, data handling, and error processing. This represents a type of middleware design concept.
 
![Object Reference](images/00/05/001.png)

After discussing the above, if the service you're working with has hundreds of methods, it's impractical to implement a static proxy for each method to introduce additional functionalities. In such cases, we would use dynamic proxies to achieve this goal.

## Dynamic proxies

In C#, dynamic proxies can be implemented using two classes: RealProxy and DispatchProxy. The former is available for use in the standard .NET Framework, while the latter is intended for use with .NET Core.


### Practical Scenario

Based on the Dynamic Proxy tutorial scenario from [MSDN](https://reurl.cc/9Z8AmV), let's assume we have a Customer Model scenario, where we interact with the data through a Repository.

Therefore, we first focus on designing the foundational infrastructure for the Context, including the implementation related to the Customer Model and Repository. The Repository will handle the usual CRUD (Create, Read, Update, Delete) operations.

![Object Reference](images/00/05/002.png)

#### Customer Model

```csharp
 public class Customer
{
  public int Id { get; set; }
  public string Name { get; set; }
  public string Address { get; set; }
}
```
#### IRepository
```csharp
 public interface IRepository<T>
{
    void Add(T entity);
    void Delete(T entity);
    void Update(T entity);
    IEnumerable<T> GetAll();
    T GetById(int id);
}
```
#### Repository
```csharp
public class Repository<T> : IRepository<T>
{
        public void Add(T entity)
        {
            Console.WriteLine("Adding {0}", entity);
        }
        public void Delete(T entity)
        {
            Console.WriteLine("Deleting {0}", entity);
        }
        public void Update(T entity)
        {
            Console.WriteLine("Updating {0}", entity);
        }
        public IEnumerable<T> GetAll()
        {
            Console.WriteLine("Getting entities");
            return null;
        }
        public T GetById(int id)
        {
            Console.WriteLine("Getting entity {0}", id);
            return default(T);
        }
}
```

After implementing the foundational infrastructure, in a scenario without using a Proxy, you can directly create a Repository instance to perform CRUD operations.

#### Main

```csharp
 class Program
    {
        static void Main(string[] args)
        {
            //Simple Use - No Logger
            Console.WriteLine("***\r\n Begin program - no logging\r\n");
            IRepository<Customer> customerRepository =
              new Repository<Customer>();
            var customer = new Customer
            {
                Id = 1,
                Name = "Customer 1",
                Address = "Address 1"
            };
            customerRepository.Add(customer);
            customerRepository.Update(customer);
            customerRepository.Delete(customer);
            Console.WriteLine("\r\nEnd program - no logging\r\n***");

        }
    }

```
The output is as follows

![Object Reference](images/00/05/003.png)

### Implementing Dynamic Proxy using RealProxy

![Object Reference](images/00/05/004.png)

#### Add logging to the Repository layer.

Now, we implement logging and Try-Catch in every CRUD operation at the Repository layer through RealProxy. Implementing Dynamic Proxy with RealProxy is quite straightforward, requiring only the implementation of the Invoke method. The underlying principle uses C# reflection to implement the methods of the entity being proxied. For those interested in a deeper exploration, consider reviewing the article on [Aspect-oriented programming](https://www.wikiwand.com/en/Aspect-oriented_programming). It discusses the principles of AOP, which are largely based on Reflection, Metaobject Protocols, and Composition Filters.

```csharp
public class DynamicProxy<T> : RealProxy
    {
        private readonly T _decorated;
        public DynamicProxy(T decorated)
          : base(typeof(T))
        {
            _decorated = decorated;
        }
        // Log Fun
        private void Log(string msg, object arg = null)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(msg, arg);
            Console.ResetColor();
        }
        // Impleation Invoke
        public override IMessage Invoke(IMessage msg)
        {
            var methodCall = msg as IMethodCallMessage;
            var methodInfo = methodCall.MethodBase as MethodInfo;

            Log("In Dynamic Proxy - Before executing '{0}'", methodCall.MethodName);

            try
            {
                var result = methodInfo.Invoke(_decorated, methodCall.InArgs);
                Log("In Dynamic Proxy - After executing '{0}' ", methodCall.MethodName);
                return new ReturnMessage(result, null, 0, methodCall.LogicalCallContext, methodCall);
            }
            catch (Exception e)
            {
                Log(string.Format("In Dynamic Proxy- Exception {0} executing '{1}'", e),methodCall.MethodName);
                return new ReturnMessage(e, methodCall);
            }
        }
    }
```
After implementing the dynamic proxy, the client-side usage is as follows.

```csharp
var repository = new Repository<Customer>();                      
var customerRepoProxy =(IRepository<Customer>)new DynamicProxy<IRepository<Customer>>(repository);

var newcustomer = new Customer
 {
    Id = 1,
    Name = "New Customer ",
    Address = "New Address"
 };
customerRepoProxy.Add(newcustomer);
customerRepoProxy.Update(newcustomer);
customerRepoProxy.Delete(newcustomer);

```
We can create a Repository factory that can flexibly generate or assemble different proxies.

```csharp
public class RepositoryFactory
{
        public static IRepository<T> Create<T>()
        {
            var repository = new Repository<T>(); 
            var decoratedRepository =(IRepository<T>)new DynamicProxy<IRepository<T>>(repository).GetTransparentProxy();
            return decoratedRepository;
        }
}
```

#### Add authentication to the Repository

By utilizing Dynamic Proxy, after adding logging and try-catch to the original Repository CRUD operations, we then attempt to construct a Dynamic Proxy to simulate method-level permission verification.

Implement an AuthenticationProxy.

```csharp
public class AuthenticationProxy<T> : RealProxy
{
        private readonly T _decorated;
        public AuthenticationProxy(T decorated)
          : base(typeof(T))
        {
            _decorated = decorated;
        }
        private void Log(string msg, object arg = null)
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine(msg, arg);
            Console.ResetColor();
        }
        public override IMessage Invoke(IMessage msg)
        {
            var methodCall = msg as IMethodCallMessage;
            var methodInfo = methodCall.MethodBase as MethodInfo;

            try
            {
                Log("User authenticated - You can execute '{0}' ",methodCall.MethodName);
                var result = methodInfo.Invoke(_decorated, methodCall.InArgs);
                return new ReturnMessage(result, null, 0,
                  methodCall.LogicalCallContext, methodCall);
            }
            catch (Exception e)
            {
                Log(string.Format(
                  "User authenticated - Exception {0} executing '{1}'", e),methodCall.MethodName);
                return new ReturnMessage(e, methodCall);
            }

            Log("User not authenticated - You can't execute '{0}' ",methodCall.MethodName);
            return new ReturnMessage(null, null, 0, methodCall.LogicalCallContext, methodCall);

        }
}
```
