## Introduction

Recently, during a discussion with a friend about mechanisms for logging, I learned about Aspect-Oriented Programming (AOP) and decided to delve a little into its usage and implementation. Although King's use of AspCore proved to be a quick way to implement AOP, I still wanted to spend some time understanding how to achieve this without relying on a framework.

AOP employs a cross-cutting technique to insert new methods into the original class without altering or disrupting the original class methods. This technique is a skillful way to introduce new functionalities into a program, enhancing its modularization and flexibility without compromising the integrity of the original code structure.

> Separate cross-cutting concerns from the core business logic to further enhance the modularity of the code!

Let me give you an example. Suppose you received the following service code that has already been written:

```csharp
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    public IXXXService(){
    
    }
    
    public void QueryData(){
        ....
    }
}
```
This service method does not provide a logging mechanism. If you want to add logging, what should you do?

The first method you might consider is directly modifying the source code.

```csharp
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    private readonly ILog _log;
    
    public IXXXService(ILog log){
        _log = log;
    }
    
    public void QueryData(){
        try{
           _log.I("QueryData");
           ....
        }
        catch(Exception e)
        {
          _log.E($"Imp QueryData " + {e.ToString()});
        }
        ....
    }
}
```

We modify the service directly by injecting your own logging function and incorporating try-catch mechanisms within the method. However, this approach clearly alters the original source code. Moreover, logging and the original logic are not directly related, so combining them isn't an ideal method.

What alternatives exist that allow us to add logging without modifying the internal code, ensuring the service retains its sole responsibility of handling business logic? One solution is to employ a simple static proxy method to achieve this.

```csharp

// 原程式碼
public interface IXXXService{
    void QueryData()
}

public class XXXService:IXXXService{
    
    public IXXXService(){
    
    }
    
    public void QueryData(){
        ....
    }
}

//使用Proxy

public class ProxyXXX : IXXXService{

    private readonly IXXXService _xxxService;
    private readonly ILog _log;
    
    public ProxyXXX(IXXXService xxxService, ILog log){
        _xxxService = xxxService;
        _log = log;
    }
    
    public void QueryData(){
        try{
            _log.I("QueryData");
            _xxxService.QueryData();
            
        }catch(Exception e){
            _log.E($"Imp QueryData " + {e.ToString()});
        }
    }

}
```

Declare a Proxy Class to implement the IXXXService method. Since this is through a proxy, there's an opportunity to intervene before and after execution actions (try-catch, log). This allows for the addition of logging functionality without altering the original code.

This concept is essentially a form of aspect-oriented programming (AOP), which separates concerns (e.g., logging) from the business core, further decoupling them.

In more detail, many program requirements, such as logging, are not directly related to the program's logic but need to be interjected into functions at appropriate times. Such requirements are typically addressed using aspects or cross-cutting concerns. This approach separates these unrelated needs from the original logical functions, enhancing the design's modifiability and reducing coupling.

The diagram conceptually illustrates that in programming, we often need to handle functions like error logging, authentication, and potentially adding user activity tracking. By applying the AOP concept, we don't have to individually add these functionalities to each method. Instead, as indicated by the grey, yellow, and red arrows, all methods must go through authentication, data handling, and error processing. This represents a type of middleware design concept.
 
![Object Reference](images/00/05/001.png)



