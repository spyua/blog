{"generatedAt":1705991842531,"generateTime":1148,"contents":[{"_path":"/code/_dir","_dir":"code","_draft":false,"_partial":true,"_locale":"","title":"codesnese","icon":"🧑‍💻","_id":"content:0.code:_dir.yml","_type":"yaml","_source":"content","_file":"0.code/_dir.yml","_extension":"yml"},{"_path":"/code/refcotr","_dir":"code","_draft":false,"_partial":false,"_locale":"","title":"重構筆記","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"重構筆記"},"children":[{"type":"text","value":"重構筆記"}]},{"type":"element","tag":"h2","props":{"id":"_20191113"},"children":[{"type":"text","value":"2019/11/13"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Lazy Class"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"別開創無所謂的Class(Ex 指宣告一個變數, Inline Class),邏輯資料相同可以使用繼承延伸,Super Class。要設計Class仙藥思考它的合理性。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Speculative Generality"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在設計時，預留太多未來可能會用的擴充點。彈性使用Template模式，然後寫成介面，ConcreateClass去設計跟Imp。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"遇到不能關閉的程式，要考慮好資源回收與OOM問題。\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1.Collapse Hierachy"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2.Inline Class"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3.Remove Parameter"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"4.Remove Method"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Temporay Field"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Class欄位過多，在替代變數命名尚不清楚會讓開發者混淆，這是在開發過程中在需求還不清楚會常遇到，盡量避免這種狀況發生。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Message Chains(過度耦合訊息練)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fun串Fun太多得意思....使用垂直折疊、提取或是使用委託與封裝，使用注入。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Middle Man(中間轉手人)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Class放與這個Class不相干的內容，邏輯提煉出來其他模組，或使用把功能寫成父類別繼承，或用注入盡量避免這件事情"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Inappropriate Intimacy(互相依賴)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"過度互相依賴，或是沒邏輯性的互相依賴(亂使用繼承)。 讀卡機讀取票卡例子(讀卡機，票卡自己也需判斷黑名單)。\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1.可以定義一個卡片Interface(鎖卡，解卡，判斷)。此Interface讓讀卡機繼承，讓讀卡機注入...(依賴注入,RW定義一個介面，再去實作)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2.使用委託註冊介面. Call Back方式把有註冊過的方式拉進Class做處理。"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Alternative Class with different Interface(異曲同工的類別)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"做Extract SuperClass"}]},{"type":"element","tag":"li","props":{},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Incomplete Libary Class(不完美程式庫類別)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果要改一點類別庫直接修改，大改套模式..EX:套裝飾者模式,或使用繼承~~~ New程式碼直接延接"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Data Class(純稚資料類別)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果你有資料結構Class專門存取，很多Class會使用他，建議寫Get Set(c#直接產生)。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Refuesed Bequest(被拒絕的遺贈)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"繼承錯誤."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Comments(過多的註釋)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"包Package或好的命名可以避免"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_20191113","depth":2,"text":"2019/11/13"}]}},"_type":"markdown","_id":"content:0.code:1.Refcotr閱讀.md","_source":"content","_file":"0.code/1.Refcotr閱讀.md","_extension":"md"},{"_path":"/","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Home","description":"","navigation":false,"layout":"page","main":{"fluid":false},"body":{"type":"root","children":[{"type":"element","tag":"ellipsis","props":{"blur":"150px","width":"75%","right":"0px"},"children":[]},{"type":"element","tag":"block-hero","props":{":cta":"[\"Blog Document\",\"/desktop\"]",":secondary":"[\"Open my GitHub →\",\"https://github.com/spyua\"]"},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hakuna Matata."}]}]},{"type":"element","tag":"template","props":{"v-slot:description":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I am a dedicated learner, and together with my friend, we have formed a team called Code Sense in Kaohsiung. We engage in research and study on a weekly basis, with a passion for learning new technologies and skills.Continual learning is the driving force of my life."}]}]},{"type":"element","tag":"template","props":{"v-slot:extra":""},"children":[{"type":"element","tag":"list","props":{},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"8-9 years of software development and maintenance experience"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"3-4 years of experience in automation domain development"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1-2 years of experience in department software training and management"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Familiar with integration and connection of various factory systems ("},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"MES"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"WMS"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"PLC"}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Proficient in web system front-end and back-end development and database design"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Well-versed in measurement instrument and motor PC Base control ("},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"RS232"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"ModBusTCP"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"EtherCAT"}]},{"type":"text","value":")"}]}]}]}]},{"type":"element","tag":"template","props":{"v-slot:support":""},"children":[{"type":"element","tag":"terminal","props":{":content":"[\"echo \\\"📚 學無止境模式啟動！\\\" > learning_journey.txt\",\"curl https://knowledge-educational-article.com | grep \\\"inspiration\\\" > inspiration.txt\",\"find / -name \\\"*idea*\\\" 2> /dev/null\",\"cat learning_journey.txt inspiration.txt > share_with_world.md\"]"},"children":[]}]}]},{"type":"element","tag":"card-grid","props":{},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"My Personal Moments."}]}]},{"type":"element","tag":"template","props":{"v-slot:root":""},"children":[{"type":"element","tag":"ellipsis","props":{"blur":"140px","width":"40rem","left":"0px","top":"10rem"},"children":[]}]},{"type":"element","tag":"card","props":{"icon":"ic:round-menu-book"},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Reading Blog"}]}]},{"type":"element","tag":"template","props":{"v-slot:description":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Regular Reading and Public Journal of Thoughts and Moods.["},{"type":"element","tag":"a","props":{"href":"https://medium.com/spyua","rel":["nofollow"]},"children":[{"type":"text","value":"Medium"}]},{"type":"text","value":"]"}]}]}]},{"type":"element","tag":"card","props":{"icon":"ic:outline-social-distance"},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Code Sense Trello"}]}]},{"type":"element","tag":"template","props":{"v-slot:description":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Regular Study and Discussion Sessions with Friends.\n["},{"type":"element","tag":"a","props":{"href":"https://trello.com/b/WgsNsCpq/%E6%91%B3sense%E8%AE%80%E6%9B%B8%E6%9C%83%E7%89%88","rel":["nofollow"]},"children":[{"type":"text","value":"Code Sense Trello"}]},{"type":"text","value":"]"}]}]}]},{"type":"element","tag":"card","props":{"icon":"ic:baseline-text-snippet"},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Slider"}]}]},{"type":"element","tag":"template","props":{"v-slot:description":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"My Presentation Slides.["},{"type":"element","tag":"a","props":{"href":"https://www.slideshare.net/ssuserb645bc","rel":["nofollow"]},"children":[{"type":"text","value":"Slider Link"}]},{"type":"text","value":"]"}]}]}]},{"type":"element","tag":"card","props":{"icon":"eos-icons:software"},"children":[{"type":"element","tag":"template","props":{"v-slot:title":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Technical Documentation"}]}]},{"type":"element","tag":"template","props":{"v-slot:description":""},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Regular document writing and temporary storage.["},{"type":"element","tag":"a","props":{"href":"https://hackmd.io/@41MKMGSpR_K11_wgmtcRgw","rel":["nofollow"]},"children":[{"type":"text","value":"Hackmd"}]},{"type":"text","value":"]"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:0.index.md","_source":"content","_file":"0.index.md","_extension":"md"},{"_path":"/architecture/_dir","_dir":"architecture","_draft":false,"_partial":true,"_locale":"","title":"Architecture","icon":"🧑‍💻","_id":"content:1.architecture:_dir.yml","_type":"yaml","_source":"content","_file":"1.architecture/_dir.yml","_extension":"yml"},{"_path":"/architecture/ddd-module","_dir":"architecture","_draft":false,"_partial":false,"_locale":"","title":"DDD實戰-Module","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ddd實戰-module"},"children":[{"type":"text","value":"DDD實戰-Module"}]},{"type":"element","tag":"h3","props":{"id":"一關於module"},"children":[{"type":"text","value":"一、關於Module"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在闡述Module前，讓我們先來比對非物件化設計與物件化設計的差異性。看到下圖左，在非物件化的傳統設計，資料與方法操作上是整個拆開設計，在資料流複雜外我們可以看相依性高，偶合的狀況也較高。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接著討論物件化設計部分，先不論封裝等物件操作技巧，單純根據資料與方法關係設計出物件(物件特性:資料(Data) 物件行為:方法(Function))，我們可以看到原本互相依賴的Fun關係可各自獨立使用，在資料流上也較為單純。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Data Fun vs Obj","src":"/blog/images/01/01/001.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"物件化後，雖然在資料操作面上簡化許多，但隨著專案功能性逐漸增加，物件與功能處理流程上會趨近越複雜，如下圖為一個簡易的系統，此系統根據外部Sensor系統獲取、過濾與計算資料，在沒模組化的設計前提，可以看到Control與Data Flow呈現一個較零散的關係狀態"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Control && Data Flow","src":"/blog/images/01/01/002.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此時我們根據Sensor功能額外設計一個Sensor模組如下，此時我們就可以針對Sensor相對應的資料模組將之封裝在模組內，此模組對外則就單純開放運算(calculation)與過濾(filtering)的功能。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模組化後可以明顯看出控制與資料流的彼此相依性值，因此降低了修改與擴充狀況的互相影響性值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Control && Data Flow 2","src":"/blog/images/01/01/003.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"模組化指是將"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"系統功能程序作分離獨立(特定功能class的容器)"}]},{"type":"text","value":"，除了功能獨立外，也強調設計上可以根據功能隨意抽換模組。達到高內聚、低耦合的目的，進而提高開發者的生產力(將複雜的功能拆分管理)。並讓程式碼能夠透過引用的方式來重複使用，提升重用性(Reusable)"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Modular design allows code to remain agile in the face of ever-changing requirements."}]}]},{"type":"element","tag":"hr","props":{"id":""},"children":[]},{"type":"element","tag":"h3","props":{"id":"二構成module考量五要素"},"children":[{"type":"text","value":"二、構成Module考量五要素"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Propose:Module功能目標單一職責，盡量不要與其他模組設計有太多相依關係。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Interface:模組功能API所提供使用方式要簡潔易懂，通常User不需要去了解實際內部的實作方式，只需專注在確定輸入什麼，會輸出什麼可達到什麼功能。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Encapsulation:封裝模組，除了讓不暴露資料結構讓使用者亂使用外，對於在修改細節上也能較不容易直接影響使用端。另外再使用抽象實作上，物件抽象化多少還是難以避免Leaky Abstractions的問題。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Implementation:實作上除了考量功能正確性外還需考慮效能、測試與功能架構程式碼最小化。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Connection(關聯性):呼應Propose功能單一職責，將與其他模組相依性最小化。"}]}]},{"type":"element","tag":"hr","props":{"id":"_1"},"children":[]},{"type":"element","tag":"h3","props":{"id":"三package-vs-module"},"children":[{"type":"text","value":"三、Package Vs Module"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在了解Module構成要素後~隨著專案模組(Module)的增加，將難以管理及問題的追蹤，這時候就能將模組(Module)打包成套件(Package)，利用其階層式的結構來彈性規劃模組(Module)。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Module:單一功能模組"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Package:多Module組成"}]}]},{"type":"element","tag":"h3","props":{"id":"四一般module設計方法"},"children":[{"type":"text","value":"四、一般Module設計方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在非以領域事件為出發點的設計上，大部分狀況會根據功能設計成物件與介面使用。下圖為Zebra SDK Package的Module列項，我們可以大致分得出，他的Module設計就是根據功能性值去區分(graphics, certificate...)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"由功能性區分","src":"/blog/images/01/01/004.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接著我們點近discovery看提供什麼API功能，可以看到可以使用的介面功能以及相關功能可使用的功能物件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"由功能性區分2","src":"/blog/images/01/01/005.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在點進個別更詳細功能介紹，我們就會看到這物件功能具有什麼資料特質、物件實體化須提供什麼參數以及此物件可使用哪些方法。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Field: address，IP or Mac Adress"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Constructor:物件實體化須提供印表機的IP or Mac Adress"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Method:可使用的物件功能，在此例看起來需實作getConnection功能"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"由功能性區分3","src":"/blog/images/01/01/006.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述為印表機找到印表機裝置功能的模組化介紹"}]},{"type":"element","tag":"hr","props":{"id":"_2"},"children":[]},{"type":"element","tag":"h3","props":{"id":"五未使用ddd的一般service服務設計"},"children":[{"type":"text","value":"五、未使用DDD的一般Service服務設計"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述一般Module設計概念聊完，在聊DDD Module設計之前先來聊一下在一般未使用DDD領域設計的服務系統會如何設計。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在對大部分的開發者，一開始習慣設計都以數據為考量的集中式設計架構。設計架構上會出現比較常見到的分層式設計，大致分成Controller, Service, Repositories, Models"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"xxx/Model\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"數據庫Model、Request Model, Response Model"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"xxx/Controller\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"給Client端的API第一時間接口，提供Get,Post,Delete,Update API。除了此在此層一般都會安插屬性驗證Client第一時間傳過來的資料是否正確。並作實際的DTO(Object 與DB Model Mapping)轉換。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"xxx/Service\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"這層基本上就是作商業邏輯的處哩，進到此層的資料基本上都是做完DTO轉換，在此層通常會作實際的資料邏輯處理處理完後再往DB方向送。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"xxx/Repositorie\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DataSource(DBContext)上一層，一般會除了實際面DataSource讀寫變更操作外，Source 資料Join處理也會在此層處理。一般多這一層都是為了隔開DataSource的來源切換，不管置換不同的DB系統，或是Source改成Shared Prefs，都可快速置換資料來源。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"一般單體架構","src":"/blog/images/01/01/007.png"},"children":[]}]},{"type":"element","tag":"hr","props":{"id":"_3"},"children":[]},{"type":"element","tag":"h3","props":{"id":"六在ddd世界中的module設計"},"children":[{"type":"text","value":"六、在DDD世界中的Module設計"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述稍微帶過Module的設計概念後，接著探討在DDD世界裡，Module的設計概念如何~大致分成幾個探討議題"}]},{"type":"element","tag":"h4","props":{"id":"_1ddd設計步驟流程"},"children":[{"type":"text","value":"1.DDD設計步驟流程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"事件風暴","src":"/blog/images/01/01/008.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在探討需求架構DDD設計的第一步，就是根據需求情境列出事件風暴(Event storming)，並在事件風暴中的用戶操作、事件、以及依賴關係根據這些要素設計歸納出領域與實體。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"接著第二步在領域實體之間找尋彼此務的關聯性，將具有相關的實體組合成聚合(Aggregate)，同時確定聚合根(Aggregate Root)。在聚合根行程時，基本上第一層邊界(邏輯邊界-虛線)也會跟著產生，他們會在同一個服務器中運行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"當聚合規劃好後~會根據業務及語意邊界等因素，將一個或多個聚合規劃訂製在一個限界上下文內(服務邊界)，形成領域模型。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"聚合","src":"/blog/images/01/01/009.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"_2程式碼一級目錄架構"},"children":[{"type":"text","value":"2.程式碼一級目錄架構"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"一級目錄架構","src":"/blog/images/01/01/010.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Interface(API Interface)\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"給使用者API介面，使用者透過Restful請求，將資料傳到此層，解析用戶傳送的請求資訊，資料的組裝、資料傳輸格式以及 Facade 介面等代碼都會放在這一層目錄裡。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Application\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"他有點像是原先集中式設計Service的功能，實作所有相依於指定前端之使用案例的地方。 例如，與 Web API 服務相關的實作。若使用的是 CQRS 方法，它便會包含查詢、微服務接受的命令，甚至是微服務之間的事件驅動通訊 (整合事件)。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Domain\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"它主要存放領域層核心業務邏輯相關的代碼。領域層可以包含多個聚合代碼包，它們共同實現領域模型的核心業務邏輯。聚合以及聚合內的實體、方法、領域服務和事件等代碼會放在這一層目錄裡。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Infrastructure\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"它主要存放基礎資源服務相關的代碼，為其它各層提供的通用技術能力、三方套裝軟體、資料庫服務、配置和基礎資源服務的代碼都會放在這一層目錄裡。"}]}]}]}]},{"type":"element","tag":"h4","props":{"id":"_3在ddd-module準則"},"children":[{"type":"text","value":"3.在DDD Module準則"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例子:如何對電商平台上的顧客進行模塊設計"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"對於顧客來說，一般須要維護顧客的"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"個人訊息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"收穫地址"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"付款方法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這三個之間的關係是緊密相關，不可獨立存在，我們根據這三點抽象出三個Aggregate"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Customer 個人訊息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AddressBook 收穫地址"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Wallet 付款方法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那該如何去放置這些Aggregate，是針對每一個Aggregate作資料夾分類還是這三個Aggregate放同一格資料夾?基本上這三個Aggregate就是一個Custer Module，所以都會放到Custer Module資料夾內。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Custer Module資料夾","src":"/blog/images/01/01/011.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當整理出Aggregate與Module後，接著會開始根據各Module去實作事件應用處理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基本上我們在DDD模塊的設計上有幾個注意要點"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Module應該要和Domain概念一致:一般一組聚合集成(領域)，我們會相對應建立一個Module。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根據通用語言來命名:模組命名要一眼就看出這是在做什麼的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"模組設計盡量鬆偶合:盡量與其他模組不要有太多的偶合，若有也許在領域設計上還沒切得很乾淨。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有PeerModule或父子Module出現，盡量避免循環相依。"}]}]},{"type":"element","tag":"h4","props":{"id":"_4關於module命名"},"children":[{"type":"text","value":"4.關於Module命名"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Module命名","src":"/blog/images/01/01/012.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"_5module界線與限界上下文不同"},"children":[{"type":"text","value":"5.Module界線與限界上下文不同"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"為了對領域模型中進行準確建模，需要將領域模型劃分成多個子域，每個子域對應一個或多個限界區域。 模塊。所以，從子域到限界某些再到模塊，應該是依次包含關係。"}]},{"type":"element","tag":"h3","props":{"id":"補充"},"children":[{"type":"text","value":"補充"}]},{"type":"element","tag":"h4","props":{"id":"補充一"},"children":[{"type":"text","value":"補充一"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Abstracion:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"將真實世界物體與事件的大量資訊縮減一個概念或是一個現象的資訊含量來將其廣義化，保存和一特定目的有關的資訊。例如，將一個皮製的足球抽象化成一個球，只保留一般球的屬性(形狀)和行為(滾)等資訊。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Leaky Abstractions\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有非不證自明的抽象概念，都有某種程度的疏漏。例如TCP雖簡化(抽象化)網路行為，設計上也保證網路傳送過程中不遺漏資訊，但不保證就真的能完整傳到資訊，例如我們無法避開海底電纜被魚咬斷因此斷訊的狀況。"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"參考"},"children":[{"type":"text","value":"參考"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/kgrzybek/modular-monolith-with-ddd#32-module-level-view","rel":["nofollow"]},"children":[{"type":"text","value":"範例"}]},{"type":"element","tag":"a","props":{"href":"https://shanebdavis.medium.com/the-5-essential-elements-of-modular-software-design-6b333918e543","rel":["nofollow"]},"children":[{"type":"text","value":"The 5 Essential Elements of Modular Software Design"}]},{"type":"element","tag":"a","props":{"href":"https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/","rel":["nofollow"]},"children":[{"type":"text","value":"The Law of Leaky Abstractions"}]},{"type":"element","tag":"a","props":{"href":"https://nordicapis.com/the-three-principles-of-excellent-api-design/","rel":["nofollow"]},"children":[{"type":"text","value":"The Three Principles of Excellent API Design"}]},{"type":"element","tag":"a","props":{"href":"https://www.learncodewithmike.com/2020/01/python-module-and-package.html","rel":["nofollow"]},"children":[{"type":"text","value":"解析Python模組(Module)和套件(Package)的概念"}]},{"type":"element","tag":"a","props":{"href":"http://www.the-software-experts.com/e_dta-sw-design-module.php","rel":["nofollow"]},"children":[{"type":"text","value":"Module Design"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/","rel":["nofollow"]},"children":[{"type":"text","value":"Domain Events vs. Integration Events in Domain-Driven Design and microservices architectures"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/sheng-jie/p/7266557.html","rel":["nofollow"]},"children":[{"type":"text","value":"DDD理论学习系列（13）-- 模块"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/sheng-jie/p/6931646.html","rel":["nofollow"]},"children":[{"type":"text","value":"DDD理论学习系列——案例及目录"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一關於module","depth":3,"text":"一、關於Module"},{"id":"二構成module考量五要素","depth":3,"text":"二、構成Module考量五要素"},{"id":"三package-vs-module","depth":3,"text":"三、Package Vs Module"},{"id":"四一般module設計方法","depth":3,"text":"四、一般Module設計方法"},{"id":"五未使用ddd的一般service服務設計","depth":3,"text":"五、未使用DDD的一般Service服務設計"},{"id":"六在ddd世界中的module設計","depth":3,"text":"六、在DDD世界中的Module設計"},{"id":"補充","depth":3,"text":"補充"},{"id":"參考","depth":3,"text":"參考"}]}},"_type":"markdown","_id":"content:1.architecture:1.DDD實戰-Module.md","_source":"content","_file":"1.architecture/1.DDD實戰-Module.md","_extension":"md"},{"_path":"/architecture/ddd","_dir":"architecture","_draft":false,"_partial":false,"_locale":"","title":"DDD實戰-簡易整理","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ddd實戰-簡易整理"},"children":[{"type":"text","value":"DDD實戰-簡易整理"}]},{"type":"element","tag":"h3","props":{"id":"一回顧"},"children":[{"type":"text","value":"一、回顧"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(DDD) 重點在於協助您在使用案例相關的商務實際情況下建立模型，然後根據Domain定義後續不同的Context與彼此的對應關係，再與事件驅動方式實際實現。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"書中所提例子 : 電商系統，人員瀏覽商並下訂後交易。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定義Domain\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根據問題空間與解決方法定義出Domain\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Core Domain :產品最有價值部分 (Ex AI 推薦購買商品需求)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Supporting Subdomain : 未提供核心競爭力，但支援核心所需功能 (Ex 購物需求)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generic Subdomain : 未提供核心競爭力，但整個系統都可能會用到它 (Ex 身份認證需求、金流串接)"}]}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"刀子譬喻","src":"/blog/images/01/02/001.png"},"children":[]},{"type":"element","tag":"img","props":{"alt":"Bounding","src":"/blog/images/01/02/002.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根據語意(Linguistic)與業務能力(Business Capability)定義BoundContext"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重點一、通常識別 Bounded Context 會由兩點下手：語意(Linguistic)與業務能力(Business Capability)。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"電商例子(語意-業務能力)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"登入-帳號管理 => 身分管理Context (Identity)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"商品-商品選擇 => 商品目錄Context (Catalog)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"下購-購買功能 => 選購Context (Purchase)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"重點二、注重業務能力勝過資料分類 (習慣性地用資料表去起始設計系統，甚至把業務邏輯與 ORM 框架綁在一起。這麼一來容易造成物件乘載太多的責任，比如說「顧客」是屬於「會員管理系統」還是屬於「購物系統」？)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Context定義出後，根據幾種方法(設計模式，或撰寫程式技巧)去做Context Mapping"},{"type":"element","tag":"pre","props":{"code":" - Shared Kernel\n - Partnership\n - Anti-corruption Layer\n - Open Host Service/Published Language\n - Separate Way\n - Big Ball of Mud\n - Customer-Supplier\n - Conformist\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" - Shared Kernel\n - Partnership\n - Anti-corruption Layer\n - Open Host Service/Published Language\n - Separate Way\n - Big Ball of Mud\n - Customer-Supplier\n - Conformist\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Context Mapping","src":"/blog/images/01/02/003.png"},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用或設計軟體架構最小化建置與維護「需求系統」所需要的人力資源。\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"軟體的架構與功能需求沒有關係"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"軟體架構是非功性需球 Non-Funcitonal Requirement (系統達成的任務的能力)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"常見軟體架構大概有這些類型：\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MVC"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MVP"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Layered Architecture"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Client Server"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Microservice"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Event-Driven Architecture"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Pipe-Filter"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MVVM"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DDD 不等於 Clean Architecture，兩者關注的面向不同。DDD 的主要目的是將軟體的模型更貼近業務需求，架構只是為了達到目的的工具。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Cost-Time Char","src":"/blog/images/01/02/004.png"},"children":[]}]},{"type":"element","tag":"hr","props":{"id":""},"children":[]},{"type":"element","tag":"h3","props":{"id":"二何謂entity如何定義他"},"children":[{"type":"text","value":"二、何謂Entity,如何定義他"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根據電商前面例子, 身分管理、 商品目錄與選購中，你覺得什麼是Entity?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顧客、訂單、商品等等。這些物件不被他們的屬性所辨識(比如年齡、金額)，而是由一個專屬的身份標誌 (Identity)來辨識。這種時候，我們就需要 Entity 的幫助讓我們在不同的物件中找到我們要的那一個。  Entity 最大的特徵就是有 Identity 的概念，所以常會搭配一個擁有唯一值的 ID 欄位。但這邊要澄清一個誤解，不是有 ID 就是 Entity，重點是你在不在乎他生命週期的變化。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Entity具有幾個特徵"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"具有唯一值ID"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"具有狀態"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生命週期有可能無限長"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一個 Entity 是可變的、長壽的，所以通常會有複雜的生命週期變化，如一套 CRUD 的操作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不只會實作資料屬性，還會實作具有相關領域邏輯的作業或方法"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"實體代表領域物件，而且主要是由其身分識別、連續性及一段時間的持續性所定義，而不只是由包含這些項目的屬性所定義。 如同 Eric Evans 說，「主要由其身分識別定義的物件稱為「實體」（Entity）。 實體在領域模型中很重要，因為它們是模型的基礎。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"已Order訂單為例子"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"訂單ID"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"訂單屬性(ID,Name,Address)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"訂單操作Method(EditName, EditAddress)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Order Class UML","src":"/blog/images/01/02/005.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"三跟valueobject有何不同"},"children":[{"type":"text","value":"三、跟ValueObject有何不同"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"當一個物件沒有概念上的標識 (conceptual identity)，而你只關心它的屬性時，這個物件就可以建立成 Value Object。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Value Object 的屬性都是為了要描述某一個事物的特徵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"判斷這兩者的標準就在於系統在不在乎這個物件的生命週期變化。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Order Class UML2","src":"/blog/images/01/02/006.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Mapping Relationship","src":"/blog/images/01/02/007.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"四如何產出-entity-id"},"children":[{"type":"text","value":"四、如何產出 Entity Id?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1. 來自用戶的輸入"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這是一個非常直接的做法，比如使用用戶的 email 或是身分證字號等等作為 ID，但也容易造成額外的成本。最大的成本就在於，你需要由用戶負責產生符合需求的身份認證資料非常困難。此時的 ID 可能是唯一的，但卻有可能是不正確的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"甚至，身分證字號也有重複的可能性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此，我們可以將用戶輸入的資料作為 Entity 的屬性。這些屬性可以用來做搜尋用，但大多時候並不適合作為 Entity 的 ID。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"2. 使用持久化機制來產生"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最常見的就是使用資料庫自動生成 ID，最常見的就是 SQL 對 ID 下 AUTO_INCREMENT 讓 ID 的值自動遞增。又或者也可以向資料庫索取一個 UUID (或 GUID) 作為 ID 的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這樣的做法好處是可以減少程式的複雜性，直接把產生的工作交給持久化機制處理。但也容易招致效能問題的疑慮(UUID/GUID 的產生)。而且當你無法從程式碼找出 ID 的生產機制時，也會增加程式碼的隱含性不利於閱讀。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，使用持久化機制時，也需要特別考量這個 ID 的生成應該要在該物件持久化 (ie 存入資料庫) 之前或是之後，以配合程式的需求。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"註：這裡會使用「持久化」一詞是因為儲存資料的方式不止資料庫一種，故用更通稱的方式描述。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3. 在程式中產生"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在程式中產生 ID 是最常見的方法之一，這種方法好處是可以更容易掌握生產的時機，此外，更可以客製化你的 ID 格式，比如一筆訂單你可以用 order-20190930-c764e787-8182 作為 ID，如此一來，在 debug 時就不用被一堆天文數字般的 ID 搞得昏頭脹腦。所以以個人經驗來說，即使增加了一點複雜度，會最推薦這個方式。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4. 由另一個 Bounded Context 提供"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最複雜的一種就是來自於另一個 Bounded Context 提供的 ID。這種可能出現在當你需要調用 API 的時候，得到對方的資料後存取下來。這種方式的複雜點在於，你不只要考慮本地端的 Entity，也需要考慮外部 Bounded Context 的改變情況，雖然可以透過訂閱另一個 Bounded Context 的方式做到，但仍舊十分麻煩。"}]},{"type":"element","tag":"h3","props":{"id":"五net-core-實作微服務領域模型"},"children":[{"type":"text","value":"五、.NET Core 實作微服務領域模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Net Demo 01","src":"/blog/images/01/02/008.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Net Demo 02","src":"/blog/images/01/02/009.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"參考 :\n"},{"type":"element","tag":"a","props":{"href":"https://ithelp.ithome.com.tw/articles/10223150","rel":["nofollow"]},"children":[{"type":"text","value":"https://ithelp.ithome.com.tw/articles/10223150"}]},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model"}]},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice","rel":["nofollow"]},"children":[{"type":"text","value":"https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一回顧","depth":3,"text":"一、回顧"},{"id":"二何謂entity如何定義他","depth":3,"text":"二、何謂Entity,如何定義他"},{"id":"三跟valueobject有何不同","depth":3,"text":"三、跟ValueObject有何不同"},{"id":"四如何產出-entity-id","depth":3,"text":"四、如何產出 Entity Id?"},{"id":"五net-core-實作微服務領域模型","depth":3,"text":"五、.NET Core 實作微服務領域模型"}]}},"_type":"markdown","_id":"content:1.architecture:2.DDD-簡易整理.md","_source":"content","_file":"1.architecture/2.DDD-簡易整理.md","_extension":"md"},{"_path":"/desktop/_dir","_dir":"desktop","_draft":false,"_partial":true,"_locale":"","title":"Desktop","icon":"🖥️","_id":"content:2.desktop:_dir.yml","_type":"yaml","_source":"content","_file":"2.desktop/_dir.yml","_extension":"yml"},{"_path":"/desktop/windowsformxxxx","_dir":"desktop","_draft":false,"_partial":false,"_locale":"","title":"WindowsForm找不到類型xxxx上的建構涵式","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"windowsform找不到類型xxxx上的建構涵式"},"children":[{"type":"text","value":"WindowsForm找不到類型xxxx上的建構涵式"}]},{"type":"element","tag":"h2","props":{"id":"情境"},"children":[{"type":"text","value":"情境"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"近期在設計DeskTop頁面時有遇到幾個頁面基底邏輯相同的狀況，於是特別設置Base Page去讓UC繼承使用。因為頁面其實長差不多，所以最後決定不使用參考引用而直接使用繼承。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"讓A(UC_3Dswitch_CalibrationFileManagement)繼承B(UC_3Dswitch_FileManagementBase)。"}]},{"type":"element","tag":"h2","props":{"id":"錯誤訊息"},"children":[{"type":"text","value":"錯誤訊息"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"編譯上都沒有問題，但此時再使用Design模式時，發生找不到類型錯誤如下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Error Message","src":"/blog/images/02/01/001.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"解決方法"},"children":[{"type":"text","value":"解決方法"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"宣告無注入空的建構子，"}]}]}]},{"type":"element","tag":"pre","props":{"className":"language-csharp github-light_github-dark","code":"\n// 宣告無注入空的建構子\npublic UC_3Dswitch_FileManagementBase()\n{\n\n}\npublic UC_3Dswitch_FileManagementBase(AppSetting appSetting) \n{\n    ProductLineDataPath = appSetting.ProductLineDataPath;\n    SNFolderNameLength = appSetting.SNFolderNameLength;\n    InitializeComponent();\n}\n","language":"csharp","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{"class":"ct-086898"},"children":[{"type":"text","value":"// 宣告無注入空的建構子\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"public"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-762058"},"children":[{"type":"text","value":"UC_3Dswitch_FileManagementBase"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"()\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"{\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"}\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"public"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-762058"},"children":[{"type":"text","value":"UC_3Dswitch_FileManagementBase"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"("}]},{"type":"element","tag":"span","props":{"class":"ct-762058"},"children":[{"type":"text","value":"AppSetting"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-762058"},"children":[{"type":"text","value":"appSetting"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":") \n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":8},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"{\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":9},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"    ProductLineDataPath "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" appSetting.ProductLineDataPath;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":10},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"    SNFolderNameLength "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" appSetting.SNFolderNameLength;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":11},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"    "}]},{"type":"element","tag":"span","props":{"class":"ct-762058"},"children":[{"type":"text","value":"InitializeComponent"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"();\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":12},"children":[{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":"}"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因原先Base設定注入所宣告AppSetting物件，故發生上述無法載入錯誤。看起來Deisnger模式在Control物件使用上Defaul都是預設空的建構子設置。"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":".github-light_github-dark{color:#24292e;background:#fff;}.dark .github-light_github-dark{color:#e1e4e8;background:#24292e;}.ct-086898{color:#6A737D;}.ct-149352{color:#D73A49;}.dark .ct-149352{color:#F97583;}.ct-553616{color:#24292E;}.dark .ct-553616{color:#E1E4E8;}.ct-762058{color:#6F42C1;}.dark .ct-762058{color:#B392F0;}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"情境","depth":2,"text":"情境"},{"id":"錯誤訊息","depth":2,"text":"錯誤訊息"},{"id":"解決方法","depth":2,"text":"解決方法"}]}},"_type":"markdown","_id":"content:2.desktop:1.WindowsForm找不到類型xxxx上的建構涵式.md","_source":"content","_file":"2.desktop/1.WindowsForm找不到類型xxxx上的建構涵式.md","_extension":"md"},{"_path":"/database/_dir","_dir":"database","_draft":false,"_partial":true,"_locale":"","title":"Database","icon":"🛢️","_id":"content:3.database:_dir.yml","_type":"yaml","_source":"content","_file":"3.database/_dir.yml","_extension":"yml"},{"_path":"/database/mssqlserver","_dir":"database","_draft":false,"_partial":false,"_locale":"","title":"MSSQL使用指令測試Server硬碟速度小技巧","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"mssql使用指令測試server硬碟速度小技巧"},"children":[{"type":"text","value":"MSSQL使用指令測試Server硬碟速度小技巧"}]},{"type":"element","tag":"h2","props":{"id":"讀取速度"},"children":[{"type":"text","value":"讀取速度"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"選抽一個資料庫 下BACKUP DATABASE指令，備分資料庫不做寫入，只做讀取，可得到讀取速度值。"}]},{"type":"element","tag":"pre","props":{"className":"language-sql github-light_github-dark","code":"BACKUP DATABASE [FUXIN_CPL] TO DISK ='NULL' WITH COPY_ONLY\n","language":"sql","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"BACKUP"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"DATABASE"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" [FUXIN_CPL] "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"TO"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"DISK"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-952708"},"children":[{"type":"text","value":"'NULL'"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"WITH"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"COPY_ONLY"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Read Speed","src":"/blog/images/03/01/001.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下圖可看到結果每秒讀取速度為180MB/sec"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Read Speed Result","src":"/blog/images/03/01/002.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"寫入速度"},"children":[{"type":"text","value":"寫入速度"}]},{"type":"element","tag":"pre","props":{"className":"language-sql github-light_github-dark","code":"BACKUP DATABASE [FUXIN_CPL] TO DISK ='C:\\TEST.BAK' WITH COPY_ONLY\n","language":"sql","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"BACKUP"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"DATABASE"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" [FUXIN_CPL] "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"TO"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"DISK"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"="}]},{"type":"element","tag":"span","props":{"class":"ct-952708"},"children":[{"type":"text","value":"'C:\\TEST.BAK'"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"WITH"}]},{"type":"element","tag":"span","props":{"class":"ct-553616"},"children":[{"type":"text","value":" "}]},{"type":"element","tag":"span","props":{"class":"ct-149352"},"children":[{"type":"text","value":"COPY_ONLY"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此時會得到讀寫時間為每秒153MB"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Write Speed Result","src":"/blog/images/03/01/003.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每秒153MB為讀寫時間，此時須作運算處裡將寫入時間算出"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"讀取總頁數共688頁，一頁8k => 688*8.0 / 1024 = 5.375M"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"寫入時間為 0.035-0.03 = 0.005"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"5.375M/0.005 = 1075M"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":".github-light_github-dark{color:#24292e;background:#fff;}.dark .github-light_github-dark{color:#e1e4e8;background:#24292e;}.ct-149352{color:#D73A49;}.dark .ct-149352{color:#F97583;}.ct-553616{color:#24292E;}.dark .ct-553616{color:#E1E4E8;}.ct-952708{color:#032F62;}.dark .ct-952708{color:#9ECBFF;}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"讀取速度","depth":2,"text":"讀取速度"},{"id":"寫入速度","depth":2,"text":"寫入速度"}]}},"_type":"markdown","_id":"content:3.database:1.MSSQL使用指令測試Server硬碟速度小技巧.md","_source":"content","_file":"3.database/1.MSSQL使用指令測試Server硬碟速度小技巧.md","_extension":"md"},{"_path":"/keycloak/_dir","_dir":"keycloak","_draft":false,"_partial":true,"_locale":"","title":"Keycloak","icon":"🔒","_id":"content:4.keycloak:_dir.yml","_type":"yaml","_source":"content","_file":"4.keycloak/_dir.yml","_extension":"yml"},{"_path":"/keycloak/keycloak","_dir":"keycloak","_draft":false,"_partial":false,"_locale":"","title":"身份驗證與授權與Keycloak","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"身份驗證與授權與keycloak"},"children":[{"type":"text","value":"身份驗證與授權與Keycloak"}]},{"type":"element","tag":"h2","props":{"id":"一關於身份驗證與授權"},"children":[{"type":"text","value":"一、關於身份驗證與授權"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"身份驗證和授權是系統安全性非常重要的環節。身份驗證用於識別使用者是誰，而授權則賦予使用者某些特定權限。更具體來說，這整個過程可以分為四個部分："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification)：這是一個讓系統知道你是誰的過程。例如，當你使用用戶名或電子郵件地址登入系統時，就是進行身分識別。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication)：這個過程讓系統確認你確實是你聲稱的那個人。通常是通過輸入密碼、使用FaceID或OTP來完成的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization)：這涉及到角色分配。根據你的角色，系統會賦予你不同的權限。例如，一個“編輯者”角色可能有編輯內容的權限，而一個“閱讀者”角色則只能閱讀。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)：這涉及到具體的操作權限。比如，在一個IT管理系統中，一個普通使用者可能可以重啟伺服器和查看系統日誌，但不能部署新的程式碼。然而，一個開發者則可能有這樣的權限。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在你登入系統，輸入帳號密碼為身分識別與身分驗證，系統驗證完後，會根據身分授予角色。至於此角色權限則可以在後台系統上設置。至於這部分的詳細實做概念牽扯還是蠻多的...會再找時間針對這部分做一個細部講解。"}]},{"type":"element","tag":"h3","props":{"id":"_1-身分識別驗證與授權簡易實作"},"children":[{"type":"text","value":"1. 身分識別驗證與授權簡易實作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"了解這些基礎概念後，我們可以考慮如何手動實現這四個部分。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification) : 最常見的實現方式是透過一個使用者註冊頁面，讓使用者輸入基本資料，例如用戶名和密碼。這些信息會被存儲在後端的資料庫中（密碼會被加密）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication) : 驗證的方法有多種。"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"密碼驗證 : 簡單地說，就是將輸入的密碼與資料庫中存儲的密碼進行比對。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多因素驗證 : 二次驗證，例如OTP、FaceID，或是手機&Mail驗證"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Session/Token管理 : 用戶登入後，系統會生成一個session或token並發送給用戶。後續的所有請求都需要這個token以確認身份。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization) : 這部分簡易實作基本上會有三部份"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色管理：在資料庫中設計一個角色和權限的模型。例如，每個使用者可以有一個或多個角色，每個角色有不同的權限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"權限檢查：每次使用者請求某個資源或操作時，檢查他們的角色是否有相應的權限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"API設計：設計API時，確保每個API端點都有適當的授權檢查。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"基於角色的存取控制 (RBAC)：根據使用者的角色決定他們可以訪問的資源。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"細緻的權限設定：允許系統管理者為每個角色定制細緻的權限，例如某角色只能讀取資料但不能編輯。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他考慮"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"日誌和監控：記錄所有的登錄嘗試、授權請求等，以便日後分析和審計。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"資料庫安全性：確保資料庫有適當的加密和備份策略。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定期檢查和更新：隨著時間的推移，可能會出現新的安全威脅。定期檢查和更新你的身份驗證和授權策略，以確保它們始終是安全的。"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"_2-身分識別驗證授權與keycloak"},"children":[{"type":"text","value":"2. 身分識別驗證、授權與Keycloak"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通過使用Keycloak，我們能夠更為高效地實現身分識別、身分驗證、授權，以及存取控制等功能。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不僅提供使用者註冊功能，讓使用者可以用基本資訊，比如用戶名或電子郵件進行註冊，還支持多種社交登入方式，如Google或Facebook。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支援多種身分驗證方法，包括密碼、OTP、FaceID等，也提供Token管理，當使用者成功登入後，Keycloak 會發放一個 token，使用者可以使用此 token 來存取其他受保護的資源。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可以定義多個角色，並為每個角色分配不同的權限，使用者可以被分配到一個或多個角色，這些角色決定了使用者可以訪問哪些資源。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支援基於角色的存取控制 (RBAC)。你可以設定哪些角色可以訪問哪些資源。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般來說，要全面實施這四大功能通常需要大量的時間和資源。開發者不只需要寫大量的程式碼，還必須維護系統的安全性、效能，並確保與其他系統的良好整合。有了Keycloak，這一切都變得相對簡單。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一關於身份驗證與授權","depth":2,"text":"一、關於身份驗證與授權","children":[{"id":"_1-身分識別驗證與授權簡易實作","depth":3,"text":"1. 身分識別驗證與授權簡易實作"},{"id":"_2-身分識別驗證授權與keycloak","depth":3,"text":"2. 身分識別驗證、授權與Keycloak"}]}]}},"_type":"markdown","_id":"content:4.keycloak:1.身份驗證與授權與Keycloak.md","_source":"content","_file":"4.keycloak/1.身份驗證與授權與Keycloak.md","_extension":"md"},{"_path":"/keycloak/oidcsaml","_dir":"keycloak","_draft":false,"_partial":false,"_locale":"","title":"OIDC vs SAML","description":"在這部分，我們將探討OIDC和SAML。正如前一章節所提，身分驗證和授權是整個安全流程中非常關鍵的環節。一般來說，會有專門的解決方案來處理這些問題。OIDC和SAML都是為這個目的而設計的標準協議，它們提供一個集中式的方法來驗證使用者身份，並界定他們可以訪問哪些資源或執行哪些操作。","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"oidc-vs-saml"},"children":[{"type":"text","value":"OIDC vs SAML"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在這部分，我們將探討OIDC和SAML。正如前一章節所提，身分驗證和授權是整個安全流程中非常關鍵的環節。一般來說，會有專門的解決方案來處理這些問題。OIDC和SAML都是為這個目的而設計的標準協議，它們提供一個集中式的方法來驗證使用者身份，並界定他們可以訪問哪些資源或執行哪些操作。"}]},{"type":"element","tag":"h3","props":{"id":"_1-open-id-connect-oidc"},"children":[{"type":"text","value":"1. Open ID Connect (OIDC)："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OIDC是一個建立在OAuth 2.0之上的身分認證層。OAuth 2.0本身是一個專注於授權的框架，而OIDC則在這個基礎上增加了身分驗證功能。這樣，應用程式不僅能知道使用者有哪些權限，還能瞭解使用者是誰，並獲取他們的基本資訊，比如名稱和電子郵件地址。"}]},{"type":"element","tag":"h4","props":{"id":"a-oauth-20"},"children":[{"type":"text","value":"a. OAuth 2.0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OAuth 2.0 是一個授權框架，允許第三方應用程式在使用者同意的情況下存取使用者在某個服務上的資訊，而不需要分享使用者的密碼。通常在OAuth 2.0，會有幾個角色，我們這邊舉一個簡單情境，你希望使用「快速日記」App，而這個App提供使用Google帳戶登入的功能來使用Google雲端硬碟服務。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Resource Owner(資源擁有者) : 通常就是User(你)， 能授予應用程式取得受保護資料的人，通常就是終端使用者（end-user）。例如你希望使用「快速日記」App，而這個App提供使用Google帳戶登入的功能。在OAuth的流程中，當App請求許可存取你的資料時，你會給予（或拒絕）這個請求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Resource Server(Resource Server) : 存放使用者受保護資料的伺服器，以這個例子來說就是Google雲端硬碟，當「快速日記」App希望保存或讀取日記時，它會向此伺服器提出請求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Client (客戶端)：通常指稱想要取得受保護資源的「應用程式」，以這個例子來說就是「快速日記」App。 當「快速日記」App希望保存或讀取日記時，它會向此伺服器提出請求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Authorization Server (授權伺服器) : 驗證 Resource Owner 的身份，並且在獲得同意之後，發放「Access Token」給應用程式（Client）的伺服器。以這個例子來說就是 (Google的授權伺服器)。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下圖整個驗證Flow"}]},{"type":"element","tag":"details","props":{},"children":[{"type":"text","value":"\n "},{"type":"element","tag":"summary","props":{},"children":[{"type":"text","value":"驗證Flow"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Client 到 Resource Owner :"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Request Credentials : 當你打開「快速日記」App並選擇使用Google帳戶登入時，App首先會引導你到Google的登入頁面。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Authenticate : 你將在Google的頁面上輸入你的Google帳戶憑證，即用戶名和密碼。這一步是由Google完成的，而「快速日記」App不會看到或知道你的密碼。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Consent : 一旦驗證成功，Google會顯示一個請求同意頁面。在這裡，Google會詢問你是否允許「快速日記」App訪問特定的Google帳戶資料。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Credentials : 「Resource Owner」（使用者）提供的身份資訊或某種用於辨識其身份的資料。這只是一個授權請求，而實際的身份驗證會在Resource Owner和Authorization Server之間完成。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"ol","props":{"start":2},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Client 到 Authorization Server"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Authorization Request : 如果你同意上述的權限請求，「快速日記」App會從Google的授權伺服器請求一個授權碼。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Authorization Code : Google的授權伺服器會回傳一個短暫的授權碼給「快速日記」App。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Access Token : ，「快速日記」App會使用這個授權碼再次向Google的授權伺服器請求取得訪問令牌（Access Token）。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"ol","props":{"start":3},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Client 到 Resource Server"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Access Token: 一旦取得訪問令牌，「快速日記」App便可以使用此令牌來存取Google雲端硬碟（或其他你同意的資料）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Protected Resource: 當「快速日記」App希望保存或讀取日記時，它會使用這個Access Token向Google雲端硬碟（作為資源伺服器）提出請求，然後Google雲端硬碟會根據該令牌提供相對應的資料或服務。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更詳細的其實還有關係到Redirect部分，可以參照這篇 "},{"type":"element","tag":"a","props":{"href":"https://cloudsundial.com/salesforce-oauth-flows","rel":["nofollow"]},"children":[{"type":"text","value":"https://cloudsundial.com/salesforce-oauth-flows"}]},{"type":"text","value":" 寫得還算詳細。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"OAuth 2.0 Flow","src":"/blog/images/04/02/001.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-open-id-connect-oidc","depth":3,"text":"1. Open ID Connect (OIDC)："}]}},"_type":"markdown","_id":"content:4.keycloak:2.OIDC與SAML.md","_source":"content","_file":"4.keycloak/2.OIDC與SAML.md","_extension":"md"},{"_path":"/keycloak/sso","_dir":"keycloak","_draft":false,"_partial":false,"_locale":"","title":"關於SSO","description":"","body":{"type":"root","children":[{"type":"element","tag":"h6","props":{"id":"tags-keycloak-tool"},"children":[{"type":"text","value":"tags: "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"keycloak"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"Tool"}]}]},{"type":"element","tag":"h2","props":{"id":"三sso-簡述"},"children":[{"type":"text","value":"三、SSO 簡述"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OIDC和SAML討論完後，我們來聊聊單一登入（SSO）。SSO是一個身份驗證方案，它讓使用者能透過一次登入就可訪問多個應用程式和網站。簡而言之："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"透過單一的登入窗口，進行單一的身分驗證，就可以讓許多的服務共同來使用這個驗證結果"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OIDC和SAML都可以實現這樣的SSO功能。舉例來說，假設你在工作中要使用三個不同的平台："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"郵件系統（Email System）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"公司內部網站（Intranet）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"報表和數據分析平台（Analytics Platform）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通常你得記住這三個系統各自的帳號和密碼。但有了SSO，你只需透過一個統一的登入界面（比如由Keycloak管理）登入一次，然後就能自由地訪問這三個不同的平台，無需再逐一輸入帳號和密碼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"總之，SSO幫你將多個獨立的系統集成為單一的入口點。這樣不僅減少了你需要記住多組密碼的困擾，還降低了由於多個系統各自存儧行密碼所帶來的安全風險。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"流程範例大致如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step1(箭頭1) : 用者首先訪問「Application 01」的 URL 並按下登入按鈕，然後會被引導到 Keycloak 登入頁面。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step2: 用戶在 Keycloak 成功登入後，將被重新導向回「Application 01」的主頁。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step3(箭頭3): 如果用戶在合理的時間內再次訪問「Application 02」，則不需要重新登入。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"箭頭2實際上是指示用戶從「應用程式01」被引導到Keycloak的登入頁面這一過程。簡單來說，當用戶嘗試在「應用程式01」登入（箭頭1）後，他們會被重定向到Keycloak以完成身份驗證（箭頭2）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"https://hackmd.io/_uploads/Sy0BScvfT.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"三sso-簡述","depth":2,"text":"三、SSO 簡述"}]}},"_type":"markdown","_id":"content:4.keycloak:3.關於SSO.md","_source":"content","_file":"4.keycloak/3.關於SSO.md","_extension":"md"}],"navigation":[{"title":"codesnese","_path":"/code","children":[{"title":"重構筆記","_path":"/code/refcotr"}],"icon":"🧑‍💻"},{"title":"Architecture","_path":"/architecture","children":[{"title":"DDD實戰-Module","_path":"/architecture/ddd-module"},{"title":"DDD實戰-簡易整理","_path":"/architecture/ddd"}],"icon":"🧑‍💻"},{"title":"Desktop","_path":"/desktop","children":[{"title":"WindowsForm找不到類型xxxx上的建構涵式","_path":"/desktop/windowsformxxxx"}],"icon":"🖥️"},{"title":"Database","_path":"/database","children":[{"title":"MSSQL使用指令測試Server硬碟速度小技巧","_path":"/database/mssqlserver"}],"icon":"🛢️"},{"title":"Keycloak","_path":"/keycloak","children":[{"title":"身份驗證與授權與Keycloak","_path":"/keycloak/keycloak"},{"title":"OIDC vs SAML","_path":"/keycloak/oidcsaml"},{"title":"關於SSO","_path":"/keycloak/sso"}],"icon":"🔒"}]}