[{"_path":"/database/ef-query","_dir":"database","_draft":false,"_partial":false,"_locale":"","title":"大批量Create處理時間議題與Query追蹤議題","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"大批量create處理時間議題與query追蹤議題"},"children":[{"type":"text","value":"大批量Create處理時間議題與Query追蹤議題"}]},{"type":"element","tag":"h2","props":{"id":"一大批量create處理時間議題"},"children":[{"type":"text","value":"一、大批量Create處理時間議題"}]},{"type":"element","tag":"h3","props":{"id":"a情境"},"children":[{"type":"text","value":"a.情境"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"近期在使用EF新增資料時遇到一次要插入大量資料時的需求(一次約快1w5千筆)。因為EF Bulk Insert要錢(第三方套件)，顧很單純使用DbContext Add，插入時間要將近30秒。"}]},{"type":"element","tag":"h3","props":{"id":"root-casue"},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-tw/ef/ef6/saving/change-tracking/auto-detect-changes","rel":["nofollow"]},"children":[{"type":"text","value":"Root Casue"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EF POCO在做異動時，會呼叫DetectChanges()比對所有entry集合中每一個Property的新就值，顧會造成在大量操作時拉長時間。以下為會呼叫DetectChanges()的方法"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.Find"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.Local"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.Add"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.AddRange"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.Remove"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.RemoveRange"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbSet.Attach"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbContext.SaveChanges"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbCoNtext.GetValidationErrors"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbContext.Entry"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DbChangeTracker.Entries"}]}]},{"type":"element","tag":"h3","props":{"id":"b解法"},"children":[{"type":"text","value":"b.解法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根據上述原因，若要縮短大量資料建立時間有兩種方法"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用AddRange\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接使用AddRange一次性加入所有資料，會比起每次Add都要呼叫一次DetectChanges()時間來的短。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Configuration.AutoDetectChangesEnabled屬性設置成false\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"直接將AutoDetectChangesEnabled設成false，Add完後再設為true。"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"c測試結果"},"children":[{"type":"text","value":"c.測試結果"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"實測結果如下，12544筆資料存取時間"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Add : 34s"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AddRange : 13s"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AutoDetectChangesEnabled fasle : 13s"}]}]},{"type":"element","tag":"h2","props":{"id":"二query追蹤議題"},"children":[{"type":"text","value":"二、"},{"type":"element","tag":"a","props":{"href":"https://docs.microsoft.com/zh-tw/ef/core/querying/tracking#tracking-queries","rel":["nofollow"]},"children":[{"type":"text","value":"Query追蹤議題"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For處理大批量Create處理時間議題也稍微查一下Query部分，發現EF查詢預設有Tracking的設計。稍微寫一下Testing Code如下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Testing Code","src":"/blog/images/03/02/001.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"操作步驟為"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step1: Context1 索取Mario資料"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step2: Context2 新增一筆Test資料"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Step3: Context1 修改Mario資料為Jack"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"結果如下"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Result","src":"/blog/images/03/02/002.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以發現Context1查覺到筆數有增加，但Context2獨到的Name能然為舊值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為Context2拿取了Cache資料內容，第二次Query並沒從DB讀取。所以讀到的值仍為舊值。此時如果我們將Context2第二查詢改為"}]},{"type":"element","tag":"pre","props":{"className":"language-= github-light_github-dark","code":"dbContext2.TestRecord.AsNoTracking().SingleOrDefault(x => x.Id == 1).Name\n","language":"=","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"dbContext2.TestRecord.AsNoTracking().SingleOrDefault(x => x.Id == 1).Name"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此時讀到的值則就會是Context1改過的Name值Jack，因此如果在唯讀的使用情境下，使用不追蹤查詢可以加快查詢速度。(待實測)"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":".github-light_github-dark{color:#24292e;background:#fff;}.dark .github-light_github-dark{color:#e1e4e8;background:#24292e;}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一大批量create處理時間議題","depth":2,"text":"一、大批量Create處理時間議題","children":[{"id":"a情境","depth":3,"text":"a.情境"},{"id":"root-casue","depth":3,"text":"Root Casue"},{"id":"b解法","depth":3,"text":"b.解法"},{"id":"c測試結果","depth":3,"text":"c.測試結果"}]},{"id":"二query追蹤議題","depth":2,"text":"二、Query追蹤議題"}]}},"_type":"markdown","_id":"content:4.database:2.EF Query追蹤議題.md","_source":"content","_file":"4.database/2.EF Query追蹤議題.md","_extension":"md"},{"_path":"/keycloak/keycloak","_dir":"keycloak","_draft":false,"_partial":false,"_locale":"","title":"身份驗證與授權與Keycloak","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"身份驗證與授權與keycloak"},"children":[{"type":"text","value":"身份驗證與授權與Keycloak"}]},{"type":"element","tag":"h2","props":{"id":"一關於身份驗證與授權"},"children":[{"type":"text","value":"一、關於身份驗證與授權"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"身份驗證和授權是系統安全性非常重要的環節。身份驗證用於識別使用者是誰，而授權則賦予使用者某些特定權限。更具體來說，這整個過程可以分為四個部分："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification)：這是一個讓系統知道你是誰的過程。例如，當你使用用戶名或電子郵件地址登入系統時，就是進行身分識別。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication)：這個過程讓系統確認你確實是你聲稱的那個人。通常是通過輸入密碼、使用FaceID或OTP來完成的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization)：這涉及到角色分配。根據你的角色，系統會賦予你不同的權限。例如，一個“編輯者”角色可能有編輯內容的權限，而一個“閱讀者”角色則只能閱讀。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)：這涉及到具體的操作權限。比如，在一個IT管理系統中，一個普通使用者可能可以重啟伺服器和查看系統日誌，但不能部署新的程式碼。然而，一個開發者則可能有這樣的權限。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在你登入系統，輸入帳號密碼為身分識別與身分驗證，系統驗證完後，會根據身分授予角色。至於此角色權限則可以在後台系統上設置。至於這部分的詳細實做概念牽扯還是蠻多的...會再找時間針對這部分做一個細部講解。"}]},{"type":"element","tag":"h3","props":{"id":"_1-身分識別驗證與授權簡易實作"},"children":[{"type":"text","value":"1. 身分識別驗證與授權簡易實作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"了解這些基礎概念後，我們可以考慮如何手動實現這四個部分。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification) : 最常見的實現方式是透過一個使用者註冊頁面，讓使用者輸入基本資料，例如用戶名和密碼。這些信息會被存儲在後端的資料庫中（密碼會被加密）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication) : 驗證的方法有多種。"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"密碼驗證 : 簡單地說，就是將輸入的密碼與資料庫中存儲的密碼進行比對。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多因素驗證 : 二次驗證，例如OTP、FaceID，或是手機&Mail驗證"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Session/Token管理 : 用戶登入後，系統會生成一個session或token並發送給用戶。後續的所有請求都需要這個token以確認身份。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization) : 這部分簡易實作基本上會有三部份"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"角色管理：在資料庫中設計一個角色和權限的模型。例如，每個使用者可以有一個或多個角色，每個角色有不同的權限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"權限檢查：每次使用者請求某個資源或操作時，檢查他們的角色是否有相應的權限。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"API設計：設計API時，確保每個API端點都有適當的授權檢查。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"基於角色的存取控制 (RBAC)：根據使用者的角色決定他們可以訪問的資源。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"細緻的權限設定：允許系統管理者為每個角色定制細緻的權限，例如某角色只能讀取資料但不能編輯。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他考慮"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"日誌和監控：記錄所有的登錄嘗試、授權請求等，以便日後分析和審計。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"資料庫安全性：確保資料庫有適當的加密和備份策略。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定期檢查和更新：隨著時間的推移，可能會出現新的安全威脅。定期檢查和更新你的身份驗證和授權策略，以確保它們始終是安全的。"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"_2-身分識別驗證授權與keycloak"},"children":[{"type":"text","value":"2. 身分識別驗證、授權與Keycloak"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通過使用Keycloak，我們能夠更為高效地實現身分識別、身分驗證、授權，以及存取控制等功能。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分識別 (Identification)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不僅提供使用者註冊功能，讓使用者可以用基本資訊，比如用戶名或電子郵件進行註冊，還支持多種社交登入方式，如Google或Facebook。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"身分驗證 (Authentication"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支援多種身分驗證方法，包括密碼、OTP、FaceID等，也提供Token管理，當使用者成功登入後，Keycloak 會發放一個 token，使用者可以使用此 token 來存取其他受保護的資源。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"授權 (Authorization)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可以定義多個角色，並為每個角色分配不同的權限，使用者可以被分配到一個或多個角色，這些角色決定了使用者可以訪問哪些資源。"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"存取控制 (Access Control)"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支援基於角色的存取控制 (RBAC)。你可以設定哪些角色可以訪問哪些資源。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般來說，要全面實施這四大功能通常需要大量的時間和資源。開發者不只需要寫大量的程式碼，還必須維護系統的安全性、效能，並確保與其他系統的良好整合。有了Keycloak，這一切都變得相對簡單。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一關於身份驗證與授權","depth":2,"text":"一、關於身份驗證與授權","children":[{"id":"_1-身分識別驗證與授權簡易實作","depth":3,"text":"1. 身分識別驗證與授權簡易實作"},{"id":"_2-身分識別驗證授權與keycloak","depth":3,"text":"2. 身分識別驗證、授權與Keycloak"}]}]}},"_type":"markdown","_id":"content:5.keycloak:1.身份驗證與授權與Keycloak.md","_source":"content","_file":"5.keycloak/1.身份驗證與授權與Keycloak.md","_extension":"md"}]