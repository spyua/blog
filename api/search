[{"id":"content:0.code:1.Refcotr閱讀.md","path":"/code/refcotr","dir":"code","title":"重構筆記","description":"","keywords":["2019/11/13"],"body":"  重構筆記  2019/11/13   Lazy Class   別開創無所謂的Class(Ex 指宣告一個變數, Inline Class),邏輯資料相同可以使用繼承延伸,Super Class。要設計Class仙藥思考它的合理性。  Speculative Generality   在設計時，預留太多未來可能會用的擴充點。彈性使用Template模式，然後寫成介面，ConcreateClass去設計跟Imp。  遇到不能關閉的程式，要考慮好資源回收與OOM問題。\n   1.Collapse Hierachy  2.Inline Class  3.Remove Parameter  4.Remove Method  Temporay Field   Class欄位過多，在替代變數命名尚不清楚會讓開發者混淆，這是在開發過程中在需求還不清楚會常遇到，盡量避免這種狀況發生。  Message Chains(過度耦合訊息練)   Fun串Fun太多得意思....使用垂直折疊、提取或是使用委託與封裝，使用注入。  Middle Man(中間轉手人)   Class放與這個Class不相干的內容，邏輯提煉出來其他模組，或使用把功能寫成父類別繼承，或用注入盡量避免這件事情  Inappropriate Intimacy(互相依賴)   過度互相依賴，或是沒邏輯性的互相依賴(亂使用繼承)。 讀卡機讀取票卡例子(讀卡機，票卡自己也需判斷黑名單)。\n   1.可以定義一個卡片Interface(鎖卡，解卡，判斷)。此Interface讓讀卡機繼承，讓讀卡機注入...(依賴注入,RW定義一個介面，再去實作)  2.使用委託註冊介面. Call Back方式把有註冊過的方式拉進Class做處理。  Alternative Class with different Interface(異曲同工的類別)   做Extract SuperClass   Incomplete Libary Class(不完美程式庫類別)   如果要改一點類別庫直接修改，大改套模式..EX:套裝飾者模式,或使用繼承~~~ New程式碼直接延接  Data Class(純稚資料類別)   如果你有資料結構Class專門存取，很多Class會使用他，建議寫Get Set(c#直接產生)。  Refuesed Bequest(被拒絕的遺贈)   繼承錯誤.  Comments(過多的註釋)   包Package或好的命名可以避免"},{"id":"content:0.index.md","path":"/","dir":"","title":"Home","description":"","keywords":[],"body":"     Hakuna Matata.   I am a dedicated learner, and together with my friend, we have formed a team called Code Sense in Kaohsiung. We engage in research and study on a weekly basis, with a passion for learning new technologies and skills.Continual learning is the driving force of my life.     8-9 years of software development and maintenance experience  3-4 years of experience in automation domain development  1-2 years of experience in department software training and management  Familiar with integration and connection of various factory systems (  MES ,   WMS ,   PLC )  Proficient in web system front-end and back-end development and database design  Well-versed in measurement instrument and motor PC Base control (  RS232 ,   ModBusTCP ,   EtherCAT )      My Personal Moments.      Reading Blog   Regular Reading and Public Journal of Thoughts and Moods.[  Medium ]    Code Sense Trello   Regular Study and Discussion Sessions with Friends.\n[  Code Sense Trello ]    Slider   My Presentation Slides.[  Slider Link ]    Technical Documentation   Regular document writing and temporary storage.[  Hackmd ]"},{"id":"content:1.architecture:1.DDD實戰-Module.md","path":"/architecture/ddd-module","dir":"architecture","title":"DDD實戰-Module","description":"","keywords":["一、關於Module","二、構成Module考量五要素","三、Package Vs Module","四、一般Module設計方法","五、未使用DDD的一般Service服務設計","六、在DDD世界中的Module設計","補充","參考"],"body":"  DDD實戰-Module  一、關於Module  在闡述Module前，讓我們先來比對非物件化設計與物件化設計的差異性。看到下圖左，在非物件化的傳統設計，資料與方法操作上是整個拆開設計，在資料流複雜外我們可以看相依性高，偶合的狀況也較高。  接著討論物件化設計部分，先不論封裝等物件操作技巧，單純根據資料與方法關係設計出物件(物件特性:資料(Data) 物件行為:方法(Function))，我們可以看到原本互相依賴的Fun關係可各自獨立使用，在資料流上也較為單純。    物件化後，雖然在資料操作面上簡化許多，但隨著專案功能性逐漸增加，物件與功能處理流程上會趨近越複雜，如下圖為一個簡易的系統，此系統根據外部Sensor系統獲取、過濾與計算資料，在沒模組化的設計前提，可以看到Control與Data Flow呈現一個較零散的關係狀態    此時我們根據Sensor功能額外設計一個Sensor模組如下，此時我們就可以針對Sensor相對應的資料模組將之封裝在模組內，此模組對外則就單純開放運算(calculation)與過濾(filtering)的功能。  模組化後可以明顯看出控制與資料流的彼此相依性值，因此降低了修改與擴充狀況的互相影響性值。    模組化指是將  系統功能程序作分離獨立(特定功能class的容器) ，除了功能獨立外，也強調設計上可以根據功能隨意抽換模組。達到高內聚、低耦合的目的，進而提高開發者的生產力(將複雜的功能拆分管理)。並讓程式碼能夠透過引用的方式來重複使用，提升重用性(Reusable)   Modular design allows code to remain agile in the face of ever-changing requirements.   二、構成Module考量五要素   Propose:Module功能目標單一職責，盡量不要與其他模組設計有太多相依關係。  Interface:模組功能API所提供使用方式要簡潔易懂，通常User不需要去了解實際內部的實作方式，只需專注在確定輸入什麼，會輸出什麼可達到什麼功能。  Encapsulation:封裝模組，除了讓不暴露資料結構讓使用者亂使用外，對於在修改細節上也能較不容易直接影響使用端。另外再使用抽象實作上，物件抽象化多少還是難以避免Leaky Abstractions的問題。  Implementation:實作上除了考量功能正確性外還需考慮效能、測試與功能架構程式碼最小化。  Connection(關聯性):呼應Propose功能單一職責，將與其他模組相依性最小化。   三、Package Vs Module  在了解Module構成要素後~隨著專案模組(Module)的增加，將難以管理及問題的追蹤，這時候就能將模組(Module)打包成套件(Package)，利用其階層式的結構來彈性規劃模組(Module)。   Module:單一功能模組  Package:多Module組成  四、一般Module設計方法  在非以領域事件為出發點的設計上，大部分狀況會根據功能設計成物件與介面使用。下圖為Zebra SDK Package的Module列項，我們可以大致分得出，他的Module設計就是根據功能性值去區分(graphics, certificate...)    接著我們點近discovery看提供什麼API功能，可以看到可以使用的介面功能以及相關功能可使用的功能物件。    在點進個別更詳細功能介紹，我們就會看到這物件功能具有什麼資料特質、物件實體化須提供什麼參數以及此物件可使用哪些方法。   Field: address，IP or Mac Adress  Constructor:物件實體化須提供印表機的IP or Mac Adress  Method:可使用的物件功能，在此例看起來需實作getConnection功能    上述為印表機找到印表機裝置功能的模組化介紹   五、未使用DDD的一般Service服務設計  上述一般Module設計概念聊完，在聊DDD Module設計之前先來聊一下在一般未使用DDD領域設計的服務系統會如何設計。  在對大部分的開發者，一開始習慣設計都以數據為考量的集中式設計架構。設計架構上會出現比較常見到的分層式設計，大致分成Controller, Service, Repositories, Models   xxx/Model\n   數據庫Model、Request Model, Response Model  xxx/Controller\n   給Client端的API第一時間接口，提供Get,Post,Delete,Update API。除了此在此層一般都會安插屬性驗證Client第一時間傳過來的資料是否正確。並作實際的DTO(Object 與DB Model Mapping)轉換。  xxx/Service\n   這層基本上就是作商業邏輯的處哩，進到此層的資料基本上都是做完DTO轉換，在此層通常會作實際的資料邏輯處理處理完後再往DB方向送。  xxx/Repositorie\n   DataSource(DBContext)上一層，一般會除了實際面DataSource讀寫變更操作外，Source 資料Join處理也會在此層處理。一般多這一層都是為了隔開DataSource的來源切換，不管置換不同的DB系統，或是Source改成Shared Prefs，都可快速置換資料來源。     六、在DDD世界中的Module設計  上述稍微帶過Module的設計概念後，接著探討在DDD世界裡，Module的設計概念如何~大致分成幾個探討議題  1.DDD設計步驟流程     在探討需求架構DDD設計的第一步，就是根據需求情境列出事件風暴(Event storming)，並在事件風暴中的用戶操作、事件、以及依賴關係根據這些要素設計歸納出領域與實體。  接著第二步在領域實體之間找尋彼此務的關聯性，將具有相關的實體組合成聚合(Aggregate)，同時確定聚合根(Aggregate Root)。在聚合根行程時，基本上第一層邊界(邏輯邊界-虛線)也會跟著產生，他們會在同一個服務器中運行。  當聚合規劃好後~會根據業務及語意邊界等因素，將一個或多個聚合規劃訂製在一個限界上下文內(服務邊界)，形成領域模型。    2.程式碼一級目錄架構     Interface(API Interface)\n   給使用者API介面，使用者透過Restful請求，將資料傳到此層，解析用戶傳送的請求資訊，資料的組裝、資料傳輸格式以及 Facade 介面等代碼都會放在這一層目錄裡。  Application\n   他有點像是原先集中式設計Service的功能，實作所有相依於指定前端之使用案例的地方。 例如，與 Web API 服務相關的實作。若使用的是 CQRS 方法，它便會包含查詢、微服務接受的命令，甚至是微服務之間的事件驅動通訊 (整合事件)。  Domain\n   它主要存放領域層核心業務邏輯相關的代碼。領域層可以包含多個聚合代碼包，它們共同實現領域模型的核心業務邏輯。聚合以及聚合內的實體、方法、領域服務和事件等代碼會放在這一層目錄裡。  Infrastructure\n   它主要存放基礎資源服務相關的代碼，為其它各層提供的通用技術能力、三方套裝軟體、資料庫服務、配置和基礎資源服務的代碼都會放在這一層目錄裡。  3.在DDD Module準則  例子:如何對電商平台上的顧客進行模塊設計  對於顧客來說，一般須要維護顧客的   個人訊息  收穫地址  付款方法  這三個之間的關係是緊密相關，不可獨立存在，我們根據這三點抽象出三個Aggregate   Customer 個人訊息  AddressBook 收穫地址  Wallet 付款方法  那該如何去放置這些Aggregate，是針對每一個Aggregate作資料夾分類還是這三個Aggregate放同一格資料夾?基本上這三個Aggregate就是一個Custer Module，所以都會放到Custer Module資料夾內。    當整理出Aggregate與Module後，接著會開始根據各Module去實作事件應用處理  基本上我們在DDD模塊的設計上有幾個注意要點   Module應該要和Domain概念一致:一般一組聚合集成(領域)，我們會相對應建立一個Module。  根據通用語言來命名:模組命名要一眼就看出這是在做什麼的。  模組設計盡量鬆偶合:盡量與其他模組不要有太多的偶合，若有也許在領域設計上還沒切得很乾淨。  如果有PeerModule或父子Module出現，盡量避免循環相依。  4.關於Module命名    5.Module界線與限界上下文不同  為了對領域模型中進行準確建模，需要將領域模型劃分成多個子域，每個子域對應一個或多個限界區域。 模塊。所以，從子域到限界某些再到模塊，應該是依次包含關係。  補充  補充一   Abstracion:\n   將真實世界物體與事件的大量資訊縮減一個概念或是一個現象的資訊含量來將其廣義化，保存和一特定目的有關的資訊。例如，將一個皮製的足球抽象化成一個球，只保留一般球的屬性(形狀)和行為(滾)等資訊。  Leaky Abstractions\n   所有非不證自明的抽象概念，都有某種程度的疏漏。例如TCP雖簡化(抽象化)網路行為，設計上也保證網路傳送過程中不遺漏資訊，但不保證就真的能完整傳到資訊，例如我們無法避開海底電纜被魚咬斷因此斷訊的狀況。  參考   範例  The 5 Essential Elements of Modular Software Design  The Law of Leaky Abstractions  The Three Principles of Excellent API Design  解析Python模組(Module)和套件(Package)的概念  Module Design   Domain Events vs. Integration Events in Domain-Driven Design and microservices architectures   DDD理论学习系列（13）-- 模块   DDD理论学习系列——案例及目录"},{"id":"content:2.desktop:1.WindowsForm找不到類型xxxx上的建構涵式.md","path":"/desktop/windowsformxxxx","dir":"desktop","title":"WindowsForm找不到類型xxxx上的建構涵式","description":"","keywords":["情境","錯誤訊息","解決方法"],"body":"  WindowsForm找不到類型xxxx上的建構涵式  情境  近期在設計DeskTop頁面時有遇到幾個頁面基底邏輯相同的狀況，於是特別設置Base Page去讓UC繼承使用。因為頁面其實長差不多，所以最後決定不使用參考引用而直接使用繼承。  讓A(UC_3Dswitch_CalibrationFileManagement)繼承B(UC_3Dswitch_FileManagementBase)。  錯誤訊息  編譯上都沒有問題，但此時再使用Design模式時，發生找不到類型錯誤如下    解決方法    宣告無注入空的建構子，       // 宣告無注入空的建構子\n   public     UC_3Dswitch_FileManagementBase  ()\n   {\n     }\n   public     UC_3Dswitch_FileManagementBase  (  AppSetting     appSetting  ) \n   {\n       ProductLineDataPath   =   appSetting.ProductLineDataPath;\n       SNFolderNameLength   =   appSetting.SNFolderNameLength;\n         InitializeComponent  ();\n   }  因原先Base設定注入所宣告AppSetting物件，故發生上述無法載入錯誤。看起來Deisnger模式在Control物件使用上Defaul都是預設空的建構子設置。  .github-light_github-dark{color:#24292e;background:#fff;}.dark .github-light_github-dark{color:#e1e4e8;background:#24292e;}.ct-086898{color:#6A737D;}.ct-149352{color:#D73A49;}.dark .ct-149352{color:#F97583;}.ct-553616{color:#24292E;}.dark .ct-553616{color:#E1E4E8;}.ct-762058{color:#6F42C1;}.dark .ct-762058{color:#B392F0;}"},{"id":"content:3.database:1.MSSQL使用指令測試Server硬碟速度小技巧.md","path":"/database/mssqlserver","dir":"database","title":"MSSQL使用指令測試Server硬碟速度小技巧","description":"","keywords":["讀取速度","寫入速度"],"body":"  MSSQL使用指令測試Server硬碟速度小技巧  讀取速度  選抽一個資料庫 下BACKUP DATABASE指令，備分資料庫不做寫入，只做讀取，可得到讀取速度值。     BACKUP     DATABASE   [FUXIN_CPL]   TO     DISK     =  'NULL'     WITH     COPY_ONLY    下圖可看到結果每秒讀取速度為180MB/sec    寫入速度     BACKUP     DATABASE   [FUXIN_CPL]   TO     DISK     =  'C:\\TEST.BAK'     WITH     COPY_ONLY  此時會得到讀寫時間為每秒153MB    每秒153MB為讀寫時間，此時須作運算處裡將寫入時間算出  讀取總頁數共688頁，一頁8k => 688*8.0 / 1024 = 5.375M  寫入時間為 0.035-0.03 = 0.005  5.375M/0.005 = 1075M  .github-light_github-dark{color:#24292e;background:#fff;}.dark .github-light_github-dark{color:#e1e4e8;background:#24292e;}.ct-149352{color:#D73A49;}.dark .ct-149352{color:#F97583;}.ct-553616{color:#24292E;}.dark .ct-553616{color:#E1E4E8;}.ct-952708{color:#032F62;}.dark .ct-952708{color:#9ECBFF;}"},{"id":"content:4.keycloak:1.身份驗證與授權與Keycloak.md","path":"/keycloak/keycloak","dir":"keycloak","title":"身份驗證與授權與Keycloak","description":"","keywords":["一、關於身份驗證與授權"],"body":"  身份驗證與授權與Keycloak  一、關於身份驗證與授權  身份驗證和授權是系統安全性非常重要的環節。身份驗證用於識別使用者是誰，而授權則賦予使用者某些特定權限。更具體來說，這整個過程可以分為四個部分：   身分識別 (Identification)：這是一個讓系統知道你是誰的過程。例如，當你使用用戶名或電子郵件地址登入系統時，就是進行身分識別。  身分驗證 (Authentication)：這個過程讓系統確認你確實是你聲稱的那個人。通常是通過輸入密碼、使用FaceID或OTP來完成的。  授權 (Authorization)：這涉及到角色分配。根據你的角色，系統會賦予你不同的權限。例如，一個“編輯者”角色可能有編輯內容的權限，而一個“閱讀者”角色則只能閱讀。  存取控制 (Access Control)：這涉及到具體的操作權限。比如，在一個IT管理系統中，一個普通使用者可能可以重啟伺服器和查看系統日誌，但不能部署新的程式碼。然而，一個開發者則可能有這樣的權限。  在你登入系統，輸入帳號密碼為身分識別與身分驗證，系統驗證完後，會根據身分授予角色。至於此角色權限則可以在後台系統上設置。至於這部分的詳細實做概念牽扯還是蠻多的...會再找時間針對這部分做一個細部講解。  1. 身分識別驗證與授權簡易實作  了解這些基礎概念後，我們可以考慮如何手動實現這四個部分。   身分識別 (Identification) : 最常見的實現方式是透過一個使用者註冊頁面，讓使用者輸入基本資料，例如用戶名和密碼。這些信息會被存儲在後端的資料庫中（密碼會被加密）。  身分驗證 (Authentication) : 驗證的方法有多種。   密碼驗證 : 簡單地說，就是將輸入的密碼與資料庫中存儲的密碼進行比對。  多因素驗證 : 二次驗證，例如OTP、FaceID，或是手機&Mail驗證  Session/Token管理 : 用戶登入後，系統會生成一個session或token並發送給用戶。後續的所有請求都需要這個token以確認身份。  授權 (Authorization) : 這部分簡易實作基本上會有三部份   角色管理：在資料庫中設計一個角色和權限的模型。例如，每個使用者可以有一個或多個角色，每個角色有不同的權限。  權限檢查：每次使用者請求某個資源或操作時，檢查他們的角色是否有相應的權限。  API設計：設計API時，確保每個API端點都有適當的授權檢查。  存取控制 (Access Control)   基於角色的存取控制 (RBAC)：根據使用者的角色決定他們可以訪問的資源。  細緻的權限設定：允許系統管理者為每個角色定制細緻的權限，例如某角色只能讀取資料但不能編輯。  其他考慮   日誌和監控：記錄所有的登錄嘗試、授權請求等，以便日後分析和審計。  資料庫安全性：確保資料庫有適當的加密和備份策略。  定期檢查和更新：隨著時間的推移，可能會出現新的安全威脅。定期檢查和更新你的身份驗證和授權策略，以確保它們始終是安全的。  2. 身分識別驗證、授權與Keycloak  通過使用Keycloak，我們能夠更為高效地實現身分識別、身分驗證、授權，以及存取控制等功能。   身分識別 (Identification)   不僅提供使用者註冊功能，讓使用者可以用基本資訊，比如用戶名或電子郵件進行註冊，還支持多種社交登入方式，如Google或Facebook。  身分驗證 (Authentication   支援多種身分驗證方法，包括密碼、OTP、FaceID等，也提供Token管理，當使用者成功登入後，Keycloak 會發放一個 token，使用者可以使用此 token 來存取其他受保護的資源。  授權 (Authorization)   可以定義多個角色，並為每個角色分配不同的權限，使用者可以被分配到一個或多個角色，這些角色決定了使用者可以訪問哪些資源。  存取控制 (Access Control)   支援基於角色的存取控制 (RBAC)。你可以設定哪些角色可以訪問哪些資源。  一般來說，要全面實施這四大功能通常需要大量的時間和資源。開發者不只需要寫大量的程式碼，還必須維護系統的安全性、效能，並確保與其他系統的良好整合。有了Keycloak，這一切都變得相對簡單。"},{"id":"content:4.keycloak:2.OIDC與SAML.md","path":"/keycloak/oidcsaml","dir":"keycloak","title":"OIDC vs SAML","description":"在這部分，我們將探討OIDC和SAML。正如前一章節所提，身分驗證和授權是整個安全流程中非常關鍵的環節。一般來說，會有專門的解決方案來處理這些問題。OIDC和SAML都是為這個目的而設計的標準協議，它們提供一個集中式的方法來驗證使用者身份，並界定他們可以訪問哪些資源或執行哪些操作。","keywords":["1. Open ID Connect (OIDC)："],"body":"  OIDC vs SAML  在這部分，我們將探討OIDC和SAML。正如前一章節所提，身分驗證和授權是整個安全流程中非常關鍵的環節。一般來說，會有專門的解決方案來處理這些問題。OIDC和SAML都是為這個目的而設計的標準協議，它們提供一個集中式的方法來驗證使用者身份，並界定他們可以訪問哪些資源或執行哪些操作。  1. Open ID Connect (OIDC)：  OIDC是一個建立在OAuth 2.0之上的身分認證層。OAuth 2.0本身是一個專注於授權的框架，而OIDC則在這個基礎上增加了身分驗證功能。這樣，應用程式不僅能知道使用者有哪些權限，還能瞭解使用者是誰，並獲取他們的基本資訊，比如名稱和電子郵件地址。  a. OAuth 2.0  OAuth 2.0 是一個授權框架，允許第三方應用程式在使用者同意的情況下存取使用者在某個服務上的資訊，而不需要分享使用者的密碼。通常在OAuth 2.0，會有幾個角色，我們這邊舉一個簡單情境，你希望使用「快速日記」App，而這個App提供使用Google帳戶登入的功能來使用Google雲端硬碟服務。   Resource Owner(資源擁有者) : 通常就是User(你)， 能授予應用程式取得受保護資料的人，通常就是終端使用者（end-user）。例如你希望使用「快速日記」App，而這個App提供使用Google帳戶登入的功能。在OAuth的流程中，當App請求許可存取你的資料時，你會給予（或拒絕）這個請求。  Resource Server(Resource Server) : 存放使用者受保護資料的伺服器，以這個例子來說就是Google雲端硬碟，當「快速日記」App希望保存或讀取日記時，它會向此伺服器提出請求。  Client (客戶端)：通常指稱想要取得受保護資源的「應用程式」，以這個例子來說就是「快速日記」App。 當「快速日記」App希望保存或讀取日記時，它會向此伺服器提出請求。  Authorization Server (授權伺服器) : 驗證 Resource Owner 的身份，並且在獲得同意之後，發放「Access Token」給應用程式（Client）的伺服器。以這個例子來說就是 (Google的授權伺服器)。  下圖整個驗證Flow  \n   驗證Flow     Client 到 Resource Owner :   Request Credentials : 當你打開「快速日記」App並選擇使用Google帳戶登入時，App首先會引導你到Google的登入頁面。  Authenticate : 你將在Google的頁面上輸入你的Google帳戶憑證，即用戶名和密碼。這一步是由Google完成的，而「快速日記」App不會看到或知道你的密碼。  Consent : 一旦驗證成功，Google會顯示一個請求同意頁面。在這裡，Google會詢問你是否允許「快速日記」App訪問特定的Google帳戶資料。  Credentials : 「Resource Owner」（使用者）提供的身份資訊或某種用於辨識其身份的資料。這只是一個授權請求，而實際的身份驗證會在Resource Owner和Authorization Server之間完成。    Client 到 Authorization Server   Authorization Request : 如果你同意上述的權限請求，「快速日記」App會從Google的授權伺服器請求一個授權碼。  Authorization Code : Google的授權伺服器會回傳一個短暫的授權碼給「快速日記」App。  Access Token : ，「快速日記」App會使用這個授權碼再次向Google的授權伺服器請求取得訪問令牌（Access Token）。    Client 到 Resource Server   Access Token: 一旦取得訪問令牌，「快速日記」App便可以使用此令牌來存取Google雲端硬碟（或其他你同意的資料）。  Protected Resource: 當「快速日記」App希望保存或讀取日記時，它會使用這個Access Token向Google雲端硬碟（作為資源伺服器）提出請求，然後Google雲端硬碟會根據該令牌提供相對應的資料或服務。  更詳細的其實還有關係到Redirect部分，可以參照這篇   https://cloudsundial.com/salesforce-oauth-flows  寫得還算詳細。  "}]